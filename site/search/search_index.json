{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Home</p> <p>Solutions to LeetCode in Go</p> <p>Explore the sections below:</p> <ul> <li>About</li> </ul>"},{"location":"about/","title":"About Me","text":"<p>About</p> <p>I m Sreedhar Goud</p> <p>A full stack developer</p> <p>Follow me on:</p> X |     GitHub |     LinkedIn |     YouTube |     Instagram |"},{"location":"license/","title":"License","text":"<p>This is under mit license</p>"},{"location":"problems/1/","title":"1","text":""},{"location":"problems/1/#two-sum","title":"Two Sum","text":"<p>Complexity Analysis</p> <ul> <li>Time Complexity: O(N)</li> <li>Space Complexity: O(1)</li> </ul> C++JavaJSTSPyGo <pre><code>class Solution {\n  public: std::vector &lt; int &gt; twoSum(std::vector &lt; int &gt; &amp; numbers, int target) {\n    std::unordered_map &lt; int, int &gt; hash;\n    for (int i = 0; i &lt; numbers.size(); i++) {\n      int diff = target - numbers[i];\n      if (hash.find(diff) != hash.end()) {\n        return {\n          hash[diff],\n          i\n        };\n      }\n      hash[numbers[i]] = i;\n    }\n    return {};\n  }\n};\n</code></pre> <pre><code>public class Solution {\npublic int[] twoSum(int[] numbers, int target) {\n    HashMap&lt;Integer, Integer&gt; hash = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; numbers.length; i++) {\n        int diff = target - numbers[i];\n        if (hash.containsKey(diff)) {\n            return new int[]{hash.get(diff), i};\n        }\n        hash.put(numbers[i], i);\n    }\n    return new int[]{};\n  }\n}\n</code></pre> <pre><code>var twoSum = function(numbers, target) {\nlet hash = new Map();\nfor (let i = 0; i &lt; numbers.length; i++) {\n    let diff = target - numbers[i];\n    if (hash.has(diff)) {\n        return [hash.get(diff), i];\n    }\n    hash.set(numbers[i], i);\n}\nreturn [];\n};\n</code></pre> <pre><code>function twoSum(numbers: number[], target: number): number[] {\nlet hash: Map&lt;number, number&gt; = new Map();\nfor (let i = 0; i &lt; numbers.length; i++) {\n    let diff = target - numbers[i];\n    if (hash.has(diff)) {\n        return [hash.get(diff)!, i];\n    }\n    hash.set(numbers[i], i);\n}\nreturn [];\n}\n</code></pre> <pre><code>def two_sum(numbers, target):\nhash_map = {}\nfor i, num in enumerate(numbers):\n    diff = target - num\n    if diff in hash_map:\n        return [hash_map[diff], i]\n    hash_map[num] = i\nreturn []\n</code></pre> <pre><code>func twoSum(numbers []int, target int) []int {\n    hash := make(map[int]int)\n    for i, num := range numbers {\n        diff := target - num\n        if idx, found := hash[diff]; found {\n            return []int{idx, i}\n        }\n        hash[num] = i\n    }\n    return nil\n}\n\nfunc main() {\n    nums := []int{2, 7, 11, 15}\n    target := 9\n    fmt.Println(twoSum(nums, target))\n}\n</code></pre>"},{"location":"problems/46/","title":"46","text":"<p>Two Sum</p> <p>Complexity Analysis</p> <ul> <li>Time Complexity: O(N)</li> <li>Space Complexity: O(1)</li> </ul> pyjs <pre><code>class Solution:\n    def permute(self, nums: List[int]) -&gt; List[List[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n        def dfs(path: List[int]) -&gt; None:\n        if len(path) == len(nums):\n            ans.append(path.copy())\n            return\n\n        for i, num in enumerate(nums):\n            if used[i]:\n            continue\n            used[i] = True\n            path.append(num)\n            dfs(path)\n            path.pop()\n            used[i] = False\n\n        dfs([])\n        return ans\n</code></pre> <pre><code>function permute(nums) {\n  const ans = [];\n\n  function dfs(used, path) {\n    if (path.length === nums.length) {\n      ans.push(path.slice()); // Clone path to avoid mutation\n      return;\n    }\n\n    for (let i = 0; i &lt; nums.length; i++) {\n      if (used[i]) continue;\n      used[i] = true;\n      path.push(nums[i]);\n      dfs(used, path);\n      path.pop();\n      used[i] = false;\n    }\n  }\n\n  dfs(new Array(nums.length).fill(false), []);\n  return ans;\n}\n</code></pre> C++ <p>``` cpp class Solution {</p> <pre><code>public:\nvector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\nvector&lt;vector&lt;int&gt;&gt; ans;\n\n    dfs(nums, vector&lt;bool&gt;(nums.size()), {}, ans);\n    return ans;\n\n    }\n\nprivate:\nvoid dfs(const vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp;&amp; used, vector&lt;int&gt;&amp;&amp; path,\nvector&lt;vector&lt;int&gt;&gt;&amp; ans) {\nif (path.size() == nums.size()) {\nans.push_back(path);\nreturn;\n}\n\nfor (int i = 0; i &lt; nums.size(); ++i) {\nif (used[i])\n    continue;\nused[i] = true;\npath.push_back(nums[i]);\ndfs(nums, move(used), move(path), ans);\npath.pop_back();\nused[i] = false;\n    }\n\n}\n\n};\n</code></pre> <p>````</p> java <p>``` java class Solution {</p> <p>public List&gt; permute(int[] nums) { List&gt; ans = new ArrayList&lt;&gt;(); <pre><code>dfs(nums, new boolean[nums.length], new ArrayList&lt;&gt;(), ans);\nreturn ans;\n</code></pre> <p>}</p> <p>private void dfs(int[] nums, boolean[] used, List path, List&gt; ans) { if (path.size() == nums.length) { ans.add(new ArrayList&lt;&gt;(path)); return; } <pre><code>for (int i = 0; i &lt; nums.length; ++i) {\n  if (used[i])\n    continue;\n  used[i] = true;\n  path.add(nums[i]);\n  dfs(nums, used, path, ans);\n  path.remove(path.size() - 1);\n  used[i] = false;\n}\n</code></pre> <p>} } ````</p>"}]}